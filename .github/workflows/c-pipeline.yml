# Locked-Jobs: [build, static-analysis-cppcheck, static-analysis-clang-tidy, static-analysis-flawfinder, static-analysis-cpplint, memory-leak-detection, duplicate-code-detection, documentation-generation, complexity-analysis, dependency-analysis, build-metrics, test, code-coverage, build-docker-image, docker-vulnerability-scan-trivy, docker-vulnerability-scan-grype, deploy-docker-container, container-health-check, deliver]
# Coverage: kept=20 / required=20 / extraneous=0
# Job-Name-Check: EXACT
# Reachability: Jenkinsfile→stages→Build,Static Analysis,Memory Leak Detection,Duplicate Code Detection,Documentation Generation,Complexity Analysis,Dependency Analysis,Build Metrics,Test,Code Coverage,Build Docker Image,Docker Image Vulnerability Scan,Deploy Docker Container,Container Health Check,Deliver
# Jobs (LOCKED, in logical execution order): build, static-analysis-cppcheck, static-analysis-clang-tidy, static-analysis-flawfinder, static-analysis-cpplint, memory-leak-detection, duplicate-code-detection, documentation-generation, complexity-analysis, dependency-analysis, build-metrics, test, code-coverage, build-docker-image, docker-vulnerability-scan-trivy, docker-vulnerability-scan-grype, deploy-docker-container, container-health-check, deliver
# Orphans (from flatten): None - all stages are reachable in linear pipeline execution
# Note: Skeleton iteration — all job `run` scripts are deferred to Post-Edit prompts.

name: Casino Game CI/CD Pipeline

on:
  workflow_dispatch:

env:
  DOCKER_IMAGE: "casino-game"
  CONTAINER_NAME: "casino-game-container"

jobs:
  #
  # TODO[regen-job]: Synthesize job for source stage/job "Build" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Build
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Build"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Build" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:25 stage('Build')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - rm -rf build@Jenkinsfile:27
  #     - cmake -B build -S .@Jenkinsfile:28
  #     - cmake --build build@Jenkinsfile:29
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build C++ Application
        run: |
          # set -euo pipefail
          # rm -rf build
          # cmake -B build -S .
          # cmake --build build
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: build/

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Static Analysis - Cppcheck" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Static Analysis→parallel→Cppcheck
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Static Analysis - Cppcheck"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Static Analysis - Cppcheck" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:44 "Cppcheck"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - sudo apt-get update || true@Jenkinsfile:35
  #     - sudo apt-get install -y cppcheck clang-tidy doxygen graphviz valgrind || true@Jenkinsfile:36
  #     - cppcheck --enable=all --inconclusive --xml --xml-version=2 --suppress=missingIncludeSystem src/ 2> cppcheck-report.xml || true@Jenkinsfile:45-50
  #     - cppcheck --enable=all --inconclusive --suppress=missingIncludeSystem src/ 2> cppcheck-report.txt || true@Jenkinsfile:52-55
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  static-analysis-cppcheck:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Install Analysis Tools
        run: |
          # set -euo pipefail
          # sudo apt-get update || true
          # sudo apt-get install -y cppcheck clang-tidy doxygen graphviz valgrind || true
      - name: Run Cppcheck Analysis
        run: |
          # set -euo pipefail
          # cppcheck --enable=all \
          #          --inconclusive \
          #          --xml \
          #          --xml-version=2 \
          #          --suppress=missingIncludeSystem \
          #          src/ 2> cppcheck-report.xml || true
          # 
          # cppcheck --enable=all \
          #          --inconclusive \
          #          --suppress=missingIncludeSystem \
          #          src/ 2> cppcheck-report.txt || true
      - name: Upload Cppcheck Reports
        uses: actions/upload-artifact@v4
        with:
          name: cppcheck-reports
          path: |
            cppcheck-report.txt
            cppcheck-report.xml

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Static Analysis - Clang-Tidy" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Static Analysis→parallel→Clang-Tidy
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Static Analysis - Clang-Tidy"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Static Analysis - Clang-Tidy" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:59 "Clang-Tidy"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - sudo apt-get update || true@Jenkinsfile:35
  #     - sudo apt-get install -y cppcheck clang-tidy doxygen graphviz valgrind || true@Jenkinsfile:36
  #     - find src/ -name '*.cpp' -exec clang-tidy {} -- -std=c++11 \; > clang-tidy-report.txt 2>&1 || true@Jenkinsfile:60
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  static-analysis-clang-tidy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Install Analysis Tools
        run: |
          # set -euo pipefail
          # sudo apt-get update || true
          # sudo apt-get install -y cppcheck clang-tidy doxygen graphviz valgrind || true
      - name: Run Clang-Tidy Analysis
        run: |
          # set -euo pipefail
          # find src/ -name '*.cpp' -exec clang-tidy {} -- -std=c++11 \; > clang-tidy-report.txt 2>&1 || true
      - name: Upload Clang-Tidy Reports
        uses: actions/upload-artifact@v4
        with:
          name: clang-tidy-reports
          path: clang-tidy-report.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Static Analysis - Flawfinder" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Static Analysis→parallel→Flawfinder
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Static Analysis - Flawfinder"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Static Analysis - Flawfinder" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:64 "Flawfinder"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - pip install --user flawfinder gcovr cpplint || true@Jenkinsfile:37
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:38
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:65
  #     - flawfinder --html --minlevel=0 src/ > flawfinder-report.html || true@Jenkinsfile:66
  #     - flawfinder --minlevel=0 src/ > flawfinder-report.txt || true@Jenkinsfile:67
  #     - flawfinder --sarif src/ > flawfinder-report.sarif || true@Jenkinsfile:68
  #   REQUIRED-READ-VARS:
  #     - HOME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  static-analysis-flawfinder:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Install Python Analysis Tools
        run: |
          # set -euo pipefail
          # pip install --user flawfinder gcovr cpplint || true
          # export PATH="$HOME/.local/bin:$PATH"
      - name: Run Flawfinder Analysis
        run: |
          # set -euo pipefail
          # export PATH="$HOME/.local/bin:$PATH"
          # flawfinder --html --minlevel=0 src/ > flawfinder-report.html || true
          # flawfinder --minlevel=0 src/ > flawfinder-report.txt || true
          # flawfinder --sarif src/ > flawfinder-report.sarif || true
      - name: Upload Flawfinder Reports
        uses: actions/upload-artifact@v4
        with:
          name: flawfinder-reports
          path: |
            flawfinder-report.html
            flawfinder-report.txt
            flawfinder-report.sarif

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Static Analysis - CPPLint" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Static Analysis→parallel→CPPLint
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Static Analysis - CPPLint"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Static Analysis - CPPLint" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:72 "CPPLint"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - pip install --user flawfinder gcovr cpplint || true@Jenkinsfile:37
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:38
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:73
  #     - find src/ -name '*.cpp' -o -name '*.h' | xargs cpplint --output=junit > cpplint-report.xml 2>&1 || true@Jenkinsfile:74
  #     - find src/ -name '*.cpp' -o -name '*.h' | xargs cpplint > cpplint-report.txt 2>&1 || true@Jenkinsfile:75
  #   REQUIRED-READ-VARS:
  #     - HOME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  static-analysis-cpplint:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Install Python Analysis Tools
        run: |
          # set -euo pipefail
          # pip install --user flawfinder gcovr cpplint || true
          # export PATH="$HOME/.local/bin:$PATH"
      - name: Run CPPLint Analysis
        run: |
          # set -euo pipefail
          # export PATH="$HOME/.local/bin:$PATH"
          # find src/ -name '*.cpp' -o -name '*.h' | xargs cpplint --output=junit > cpplint-report.xml 2>&1 || true
          # find src/ -name '*.cpp' -o -name '*.h' | xargs cpplint > cpplint-report.txt 2>&1 || true
      - name: Upload CPPLint Reports
        uses: actions/upload-artifact@v4
        with:
          name: cpplint-reports
          path: |
            cpplint-report.txt
            cpplint-report.xml

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Memory Leak Detection" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Memory Leak Detection
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Memory Leak Detection"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Memory Leak Detection" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:83 stage('Memory Leak Detection')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - export JENKINS_HOME=/tmp@Jenkinsfile:85
  #     - valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-report.txt ./build/test_game || true@Jenkinsfile:86-91
  #     - echo "=== Valgrind Memory Leak Analysis ===" > valgrind-summary.txt@Jenkinsfile:93
  #     - grep -E "ERROR SUMMARY|definitely lost|indirectly lost|possibly lost" valgrind-report.txt >> valgrind-summary.txt || true@Jenkinsfile:94
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  memory-leak-detection:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build/
      - name: Install Valgrind
        run: |
          # set -euo pipefail
          # sudo apt-get update || true
          # sudo apt-get install -y valgrind || true
      - name: Run Memory Leak Detection
        run: |
          # set -euo pipefail
          # export JENKINS_HOME=/tmp
          # valgrind --leak-check=full \
          #          --show-leak-kinds=all \
          #          --track-origins=yes \
          #          --verbose \
          #          --log-file=valgrind-report.txt \
          #          ./build/test_game || true
          # 
          # echo "=== Valgrind Memory Leak Analysis ===" > valgrind-summary.txt
          # grep -E "ERROR SUMMARY|definitely lost|indirectly lost|possibly lost" valgrind-report.txt >> valgrind-summary.txt || true
      - name: Upload Valgrind Reports
        uses: actions/upload-artifact@v4
        with:
          name: valgrind-reports
          path: |
            valgrind-report.txt
            valgrind-summary.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Duplicate Code Detection" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Duplicate Code Detection
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Duplicate Code Detection"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Duplicate Code Detection" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:99 stage('Duplicate Code Detection')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - if [ ! -f pmd-bin/bin/pmd ]; then@Jenkinsfile:101
  #     - wget -q https://github.com/pmd/pmd/releases/download/pmd_releases%2F7.9.0/pmd-dist-7.9.0-bin.zip || true@Jenkinsfile:102
  #     - unzip -q pmd-dist-7.9.0-bin.zip || true@Jenkinsfile:103
  #     - mv pmd-bin-7.9.0 pmd-bin || true@Jenkinsfile:104
  #     - fi@Jenkinsfile:105
  #     - ./pmd-bin/bin/pmd cpd --minimum-tokens 50 --language cpp --dir src/ --format text > cpd-report.txt || true@Jenkinsfile:107-111
  #     - ./pmd-bin/bin/pmd cpd --minimum-tokens 50 --language cpp --dir src/ --format xml > cpd-report.xml || true@Jenkinsfile:113-117
  #     - echo "=== Duplicate Code Detection Summary ===" > cpd-summary.txt@Jenkinsfile:119
  #     - grep -c "Found" cpd-report.txt >> cpd-summary.txt || echo "0 duplicates found" >> cpd-summary.txt@Jenkinsfile:120
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  duplicate-code-detection:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download and Setup PMD
        run: |
          # set -euo pipefail
          # if [ ! -f pmd-bin/bin/pmd ]; then
          #     wget -q https://github.com/pmd/pmd/releases/download/pmd_releases%2F7.9.0/pmd-dist-7.9.0-bin.zip || true
          #     unzip -q pmd-dist-7.9.0-bin.zip || true
          #     mv pmd-bin-7.9.0 pmd-bin || true
          # fi
      - name: Run Duplicate Code Detection
        run: |
          # set -euo pipefail
          # ./pmd-bin/bin/pmd cpd --minimum-tokens 50 \
          #                       --language cpp \
          #                       --dir src/ \
          #                       --format text > cpd-report.txt || true
          # 
          # ./pmd-bin/bin/pmd cpd --minimum-tokens 50 \
          #                       --language cpp \
          #                       --dir src/ \
          #                       --format xml > cpd-report.xml || true
          # 
          # echo "=== Duplicate Code Detection Summary ===" > cpd-summary.txt
          # grep -c "Found" cpd-report.txt >> cpd-summary.txt || echo "0 duplicates found" >> cpd-summary.txt
      - name: Upload CPD Reports
        uses: actions/upload-artifact@v4
        with:
          name: cpd-reports
          path: |
            cpd-report.txt
            cpd-report.xml
            cpd-summary.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Documentation Generation" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Documentation Generation
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Documentation Generation"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Documentation Generation" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:125 stage('Documentation Generation')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - if [ ! -f Doxyfile ]; then@Jenkinsfile:127
  #     - doxygen -g Doxyfile@Jenkinsfile:128
  #     - sed -i 's/PROJECT_NAME           = "My Project"/PROJECT_NAME           = "Casino Game"/' Doxyfile@Jenkinsfile:129
  #     - sed -i 's/OUTPUT_DIRECTORY       =/OUTPUT_DIRECTORY       = docs/' Doxyfile@Jenkinsfile:130
  #     - sed -i 's/INPUT                  =/INPUT                  = src/' Doxyfile@Jenkinsfile:131
  #     - sed -i 's/RECURSIVE              = NO/RECURSIVE              = YES/' Doxyfile@Jenkinsfile:132
  #     - sed -i 's/GENERATE_HTML          = YES/GENERATE_HTML          = YES/' Doxyfile@Jenkinsfile:133
  #     - sed -i 's/GENERATE_LATEX         = YES/GENERATE_LATEX         = NO/' Doxyfile@Jenkinsfile:134
  #     - sed -i 's/EXTRACT_ALL            = NO/EXTRACT_ALL            = YES/' Doxyfile@Jenkinsfile:135
  #     - sed -i 's/HAVE_DOT               = NO/HAVE_DOT               = YES/' Doxyfile@Jenkinsfile:136
  #     - sed -i 's/UML_LOOK               = NO/UML_LOOK               = YES/' Doxyfile@Jenkinsfile:137
  #     - sed -i 's/CALL_GRAPH             = NO/CALL_GRAPH             = YES/' Doxyfile@Jenkinsfile:138
  #     - sed -i 's/CALLER_GRAPH           = NO/CALLER_GRAPH           = YES/' Doxyfile@Jenkinsfile:139
  #     - fi@Jenkinsfile:140
  #     - doxygen Doxyfile || true@Jenkinsfile:142
  #     - echo "=== Documentation Generation Report ===" > doxygen-summary.txt@Jenkinsfile:144
  #     - echo "Generated on: $(date)" >> doxygen-summary.txt@Jenkinsfile:145
  #     - echo "Files documented: $(find src/ -name '*.cpp' -o -name '*.h' | wc -l)" >> doxygen-summary.txt@Jenkinsfile:146
  #     - echo "HTML Documentation: docs/html/index.html" >> doxygen-summary.txt@Jenkinsfile:147
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  documentation-generation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Doxygen and Graphviz
        run: |
          # set -euo pipefail
          # sudo apt-get update || true
          # sudo apt-get install -y doxygen graphviz || true
      - name: Generate Documentation
        run: |
          # set -euo pipefail
          # if [ ! -f Doxyfile ]; then
          #     doxygen -g Doxyfile
          #     sed -i 's/PROJECT_NAME           = "My Project"/PROJECT_NAME           = "Casino Game"/' Doxyfile
          #     sed -i 's/OUTPUT_DIRECTORY       =/OUTPUT_DIRECTORY       = docs/' Doxyfile
          #     sed -i 's/INPUT                  =/INPUT                  = src/' Doxyfile
          #     sed -i 's/RECURSIVE              = NO/RECURSIVE              = YES/' Doxyfile
          #     sed -i 's/GENERATE_HTML          = YES/GENERATE_HTML          = YES/' Doxyfile
          #     sed -i 's/GENERATE_LATEX         = YES/GENERATE_LATEX         = NO/' Doxyfile
          #     sed -i 's/EXTRACT_ALL            = NO/EXTRACT_ALL            = YES/' Doxyfile
          #     sed -i 's/HAVE_DOT               = NO/HAVE_DOT               = YES/' Doxyfile
          #     sed -i 's/UML_LOOK               = NO/UML_LOOK               = YES/' Doxyfile
          #     sed -i 's/CALL_GRAPH             = NO/CALL_GRAPH             = YES/' Doxyfile
          #     sed -i 's/CALLER_GRAPH           = NO/CALLER_GRAPH           = YES/' Doxyfile
          # fi
          # 
          # doxygen Doxyfile || true
          # 
          # echo "=== Documentation Generation Report ===" > doxygen-summary.txt
          # echo "Generated on: $(date)" >> doxygen-summary.txt
          # echo "Files documented: $(find src/ -name '*.cpp' -o -name '*.h' | wc -l)" >> doxygen-summary.txt
          # echo "HTML Documentation: docs/html/index.html" >> doxygen-summary.txt
      - name: Upload Documentation
        uses: actions/upload-artifact@v4
        with:
          name: documentation
          path: |
            docs/
            Doxyfile
            doxygen-summary.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Complexity Analysis" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Complexity Analysis
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Complexity Analysis"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Complexity Analysis" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:153 stage('Complexity Analysis')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - pip install --user lizard || true@Jenkinsfile:155
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:156
  #     - lizard src/ -o lizard-report.html || true@Jenkinsfile:158
  #     - lizard src/ > lizard-report.txt || true@Jenkinsfile:159
  #     - echo "=== Cyclomatic Complexity Analysis ===" > complexity-summary.txt@Jenkinsfile:161
  #     - echo "Functions with complexity > 15:" >> complexity-summary.txt@Jenkinsfile:162
  #     - lizard src/ | grep -E "^[[:space:]]*[0-9]+" | awk '$1 > 15 {print}' >> complexity-summary.txt || true@Jenkinsfile:163
  #   REQUIRED-READ-VARS:
  #     - HOME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  complexity-analysis:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Lizard
        run: |
          # set -euo pipefail
          # pip install --user lizard || true
          # export PATH="$HOME/.local/bin:$PATH"
      - name: Run Complexity Analysis
        run: |
          # set -euo pipefail
          # export PATH="$HOME/.local/bin:$PATH"
          # 
          # lizard src/ -o lizard-report.html || true
          # lizard src/ > lizard-report.txt || true
          # 
          # echo "=== Cyclomatic Complexity Analysis ===" > complexity-summary.txt
          # echo "Functions with complexity > 15:" >> complexity-summary.txt
          # lizard src/ | grep -E "^[[:space:]]*[0-9]+" | awk '$1 > 15 {print}' >> complexity-summary.txt || true
      - name: Upload Complexity Reports
        uses: actions/upload-artifact@v4
        with:
          name: complexity-reports
          path: |
            lizard-report.html
            lizard-report.txt
            complexity-summary.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Dependency Analysis" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Dependency Analysis
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Dependency Analysis"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Dependency Analysis" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:169 stage('Dependency Analysis')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - echo "=== Include Dependency Analysis ===" > dependency-report.txt@Jenkinsfile:171
  #     - echo "Generated on: $(date)" >> dependency-report.txt@Jenkinsfile:172
  #     - echo "" >> dependency-report.txt@Jenkinsfile:173
  #     - for file in src/*.cpp; do@Jenkinsfile:175
  #     - echo "File: $file" >> dependency-report.txt@Jenkinsfile:176
  #     - echo "Includes:" >> dependency-report.txt@Jenkinsfile:177
  #     - grep -E "^#include" "$file" | sed 's/^/  /' >> dependency-report.txt || true@Jenkinsfile:178
  #     - echo "" >> dependency-report.txt@Jenkinsfile:179
  #     - done@Jenkinsfile:180
  #     - echo "=== External Library Dependencies ===" >> dependency-report.txt@Jenkinsfile:182
  #     - grep -rh "^#include <" src/ | sort -u >> dependency-report.txt || true@Jenkinsfile:183
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  dependency-analysis:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Analyze Dependencies
        run: |
          # set -euo pipefail
          # echo "=== Include Dependency Analysis ===" > dependency-report.txt
          # echo "Generated on: $(date)" >> dependency-report.txt
          # echo "" >> dependency-report.txt
          # 
          # for file in src/*.cpp; do
          #     echo "File: $file" >> dependency-report.txt
          #     echo "Includes:" >> dependency-report.txt
          #     grep -E "^#include" "$file" | sed 's/^/  /' >> dependency-report.txt || true
          #     echo "" >> dependency-report.txt
          # done
          # 
          # echo "=== External Library Dependencies ===" >> dependency-report.txt
          # grep -rh "^#include <" src/ | sort -u >> dependency-report.txt || true
      - name: Upload Dependency Report
        uses: actions/upload-artifact@v4
        with:
          name: dependency-report
          path: dependency-report.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Build Metrics" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Build Metrics
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Build Metrics"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Build Metrics" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:189 stage('Build Metrics')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - echo "=== Build Metrics Report ===" > build-metrics.txt@Jenkinsfile:191
  #     - echo "Build Number: ${BUILD_NUMBER}" >> build-metrics.txt@Jenkinsfile:192
  #     - echo "Build Date: $(date)" >> build-metrics.txt@Jenkinsfile:193
  #     - echo "" >> build-metrics.txt@Jenkinsfile:194
  #     - echo "Lines of Code:" >> build-metrics.txt@Jenkinsfile:196
  #     - find src/ -name '*.cpp' -o -name '*.h' | xargs wc -l | tail -1 >> build-metrics.txt@Jenkinsfile:197
  #     - echo "" >> build-metrics.txt@Jenkinsfile:199
  #     - echo "File Counts:" >> build-metrics.txt@Jenkinsfile:200
  #     - echo "C++ Source Files: $(find src/ -name '*.cpp' | wc -l)" >> build-metrics.txt@Jenkinsfile:201
  #     - echo "Header Files: $(find src/ -name '*.h' | wc -l)" >> build-metrics.txt@Jenkinsfile:202
  #     - echo "" >> build-metrics.txt@Jenkinsfile:204
  #     - echo "Binary Size:" >> build-metrics.txt@Jenkinsfile:205
  #     - ls -lh build/casino_game build/test_game | awk '{print $9 ": " $5}' >> build-metrics.txt || true@Jenkinsfile:206
  #   REQUIRED-READ-VARS:
  #     - BUILD_NUMBER (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  build-metrics:
    runs-on: ubuntu-latest
    needs: build
    env:
      BUILD_NUMBER: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build/
      - name: Generate Build Metrics
        run: |
          # set -euo pipefail
          # echo "=== Build Metrics Report ===" > build-metrics.txt
          # echo "Build Number: ${BUILD_NUMBER}" >> build-metrics.txt
          # echo "Build Date: $(date)" >> build-metrics.txt
          # echo "" >> build-metrics.txt
          # 
          # echo "Lines of Code:" >> build-metrics.txt
          # find src/ -name '*.cpp' -o -name '*.h' | xargs wc -l | tail -1 >> build-metrics.txt
          # 
          # echo "" >> build-metrics.txt
          # echo "File Counts:" >> build-metrics.txt
          # echo "C++ Source Files: $(find src/ -name '*.cpp' | wc -l)" >> build-metrics.txt
          # echo "Header Files: $(find src/ -name '*.h' | wc -l)" >> build-metrics.txt
          # 
          # echo "" >> build-metrics.txt
          # echo "Binary Size:" >> build-metrics.txt
          # ls -lh build/casino_game build/test_game | awk '{print $9 ": " $5}' >> build-metrics.txt || true
      - name: Upload Build Metrics
        uses: actions/upload-artifact@v4
        with:
          name: build-metrics
          path: build-metrics.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Test" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Test
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Test"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Test" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:212 stage('Test')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - export JENKINS_HOME=/tmp@Jenkinsfile:214
  #     - ./build/casino_game || true@Jenkinsfile:215
  #     - ./build/test_game@Jenkinsfile:216
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build/
      - name: Make Executables Runnable
        run: |
          # set -euo pipefail
          # chmod +x build/casino_game build/test_game
      - name: Run Tests
        run: |
          # set -euo pipefail
          # export JENKINS_HOME=/tmp
          # ./build/casino_game || true
          # ./build/test_game

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Code Coverage" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Code Coverage
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Code Coverage"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Code Coverage" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:222 stage('Code Coverage')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - cmake -B build-coverage -S . -DCMAKE_CXX_FLAGS="--coverage"@Jenkinsfile:224
  #     - cmake --build build-coverage@Jenkinsfile:225
  #     - export JENKINS_HOME=/tmp@Jenkinsfile:227
  #     - ./build-coverage/test_game || true@Jenkinsfile:228
  #     - export PATH="$HOME/.local/bin:$PATH"@Jenkinsfile:230
  #     - gcovr -r . --html --html-details -o coverage-report.html || true@Jenkinsfile:232
  #     - gcovr -r . --txt -o coverage-report.txt || true@Jenkinsfile:233
  #     - echo "=== Code Coverage Summary ===" > coverage-summary.txt@Jenkinsfile:235
  #     - gcovr -r . | tail -5 >> coverage-summary.txt || true@Jenkinsfile:236
  #   REQUIRED-READ-VARS:
  #     - HOME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  code-coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Coverage Tools
        run: |
          # set -euo pipefail
          # pip install --user gcovr || true
          # export PATH="$HOME/.local/bin:$PATH"
      - name: Build with Coverage
        run: |
          # set -euo pipefail
          # cmake -B build-coverage -S . -DCMAKE_CXX_FLAGS="--coverage"
          # cmake --build build-coverage
      - name: Run Coverage Tests
        run: |
          # set -euo pipefail
          # export JENKINS_HOME=/tmp
          # chmod +x build-coverage/test_game
          # ./build-coverage/test_game || true
      - name: Generate Coverage Reports
        run: |
          # set -euo pipefail
          # export PATH="$HOME/.local/bin:$PATH"
          # 
          # gcovr -r . --html --html-details -o coverage-report.html || true
          # gcovr -r . --txt -o coverage-report.txt || true
          # 
          # echo "=== Code Coverage Summary ===" > coverage-summary.txt
          # gcovr -r . | tail -5 >> coverage-summary.txt || true
      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            coverage-report.html
            coverage-report.txt
            coverage-summary.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Build Docker Image" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Build Docker Image
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Build Docker Image"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Build Docker Image" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:242 stage('Build Docker Image')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - if [ ! -f Dockerfile ]; then@Jenkinsfile:246
  #     - echo "ERROR: Dockerfile not found in repository!"@Jenkinsfile:247
  #     - exit 1@Jenkinsfile:248
  #     - fi@Jenkinsfile:249
  #     - docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .@Jenkinsfile:252
  #     - docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest@Jenkinsfile:253
  #     - echo "=== Using Dockerfile from repository ===" > dockerfile-info.txt@Jenkinsfile:256
  #     - cat Dockerfile >> dockerfile-info.txt@Jenkinsfile:257
  #   REQUIRED-READ-VARS:
  #     - DOCKER_IMAGE (from env)
  #     - DOCKER_TAG (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  build-docker-image:
    runs-on: ubuntu-latest
    needs: build
    env:
      DOCKER_TAG: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build/
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build Docker Image
        run: |
          # set -euo pipefail
          # # Verify Dockerfile exists in repo
          # if [ ! -f Dockerfile ]; then
          #     echo "ERROR: Dockerfile not found in repository!"
          #     exit 1
          # fi
          # 
          # # Build Docker image using Dockerfile from repo
          # docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
          # docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
          # 
          # # Display Dockerfile content for verification
          # echo "=== Using Dockerfile from repository ===" > dockerfile-info.txt
          # cat Dockerfile >> dockerfile-info.txt
      - name: Upload Dockerfile Info
        uses: actions/upload-artifact@v4
        with:
          name: dockerfile-info
          path: dockerfile-info.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Docker Image Vulnerability Scan - Trivy" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Docker Image Vulnerability Scan→parallel→Trivy
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Docker Image Vulnerability Scan - Trivy"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Docker Image Vulnerability Scan - Trivy" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:275 "Trivy"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - if ! which trivy; then@Jenkinsfile:266
  #     - wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add - || true@Jenkinsfile:267
  #     - echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list@Jenkinsfile:268
  #     - sudo apt-get update && sudo apt-get install -y trivy || true@Jenkinsfile:269
  #     - fi@Jenkinsfile:270
  #     - trivy image --download-db-only || true@Jenkinsfile:276
  #     - trivy image --format json --output trivy-report.json ${DOCKER_IMAGE}:${DOCKER_TAG} || true@Jenkinsfile:277
  #     - trivy image --format table --output trivy-report.txt ${DOCKER_IMAGE}:${DOCKER_TAG} || true@Jenkinsfile:278
  #     - trivy image --severity HIGH,CRITICAL --format table --output trivy-critical-report.txt ${DOCKER_IMAGE}:${DOCKER_TAG} || true@Jenkinsfile:279
  #   REQUIRED-READ-VARS:
  #     - DOCKER_IMAGE (from env)
  #     - DOCKER_TAG (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  docker-vulnerability-scan-trivy:
    runs-on: ubuntu-latest
    needs: build-docker-image
    env:
      DOCKER_TAG: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Rebuild Docker Image for Scanning
        run: |
          # set -euo pipefail
          # docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
      - name: Install Trivy
        run: |
          # set -euo pipefail
          # if ! which trivy; then
          #     wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add - || true
          #     echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          #     sudo apt-get update && sudo apt-get install -y trivy || true
          # fi
      - name: Run Trivy Vulnerability Scan
        run: |
          # set -euo pipefail
          # trivy image --download-db-only || true
          # trivy image --format json --output trivy-report.json ${DOCKER_IMAGE}:${DOCKER_TAG} || true
          # trivy image --format table --output trivy-report.txt ${DOCKER_IMAGE}:${DOCKER_TAG} || true
          # trivy image --severity HIGH,CRITICAL --format table --output trivy-critical-report.txt ${DOCKER_IMAGE}:${DOCKER_TAG} || true
      - name: Upload Trivy Reports
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            trivy-report.txt
            trivy-critical-report.txt
            trivy-report.json

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Docker Image Vulnerability Scan - Grype" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Docker Image Vulnerability Scan→parallel→Grype
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Docker Image Vulnerability Scan - Grype"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Docker Image Vulnerability Scan - Grype" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:283 "Grype"
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - if ! which grype; then@Jenkinsfile:272
  #     - curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sudo sh -s -- -b /usr/local/bin || true@Jenkinsfile:273
  #     - fi@Jenkinsfile:274
  #     - grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o json > grype-report.json || true@Jenkinsfile:284
  #     - grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o table > grype-report.txt || true@Jenkinsfile:285
  #     - grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o sarif > grype-report.sarif || true@Jenkinsfile:286
  #   REQUIRED-READ-VARS:
  #     - DOCKER_IMAGE (from env)
  #     - DOCKER_TAG (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  docker-vulnerability-scan-grype:
    runs-on: ubuntu-latest
    needs: build-docker-image
    env:
      DOCKER_TAG: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Rebuild Docker Image for Scanning
        run: |
          # set -euo pipefail
          # docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
      - name: Install Grype
        run: |
          # set -euo pipefail
          # if ! which grype; then
          #     curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sudo sh -s -- -b /usr/local/bin || true
          # fi
      - name: Run Grype Vulnerability Scan
        run: |
          # set -euo pipefail
          # grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o json > grype-report.json || true
          # grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o table > grype-report.txt || true
          # grype ${DOCKER_IMAGE}:${DOCKER_TAG} -o sarif > grype-report.sarif || true
      - name: Upload Grype Reports
        uses: actions/upload-artifact@v4
        with:
          name: grype-reports
          path: |
            grype-report.txt
            grype-report.json
            grype-report.sarif

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Deploy Docker Container" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Deploy Docker Container
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Deploy Docker Container"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Deploy Docker Container" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:294 stage('Deploy Docker Container')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - docker stop ${CONTAINER_NAME} 2>/dev/null || true@Jenkinsfile:297
  #     - docker rm ${CONTAINER_NAME} 2>/dev/null || true@Jenkinsfile:298
  #     - docker run -d --name ${CONTAINER_NAME} --restart unless-stopped ${DOCKER_IMAGE}:${DOCKER_TAG}@Jenkinsfile:300-303
  #     - sleep 5@Jenkinsfile:305
  #   REQUIRED-READ-VARS:
  #     - CONTAINER_NAME (from env)
  #     - DOCKER_IMAGE (from env)
  #     - DOCKER_TAG (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  deploy-docker-container:
    runs-on: ubuntu-latest
    needs: build-docker-image
    env:
      DOCKER_TAG: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Rebuild Docker Image for Deployment
        run: |
          # set -euo pipefail
          # docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
      - name: Deploy Docker Container
        run: |
          # set -euo pipefail
          # docker stop ${CONTAINER_NAME} 2>/dev/null || true
          # docker rm ${CONTAINER_NAME} 2>/dev/null || true
          # 
          # docker run -d \
          #     --name ${CONTAINER_NAME} \
          #     --restart unless-stopped \
          #     ${DOCKER_IMAGE}:${DOCKER_TAG}
          # 
          # sleep 5

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Container Health Check" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Container Health Check
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Container Health Check"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Container Health Check" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:311 stage('Container Health Check')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - echo "=== Container Health Check Report ===" > container-health-report.txt@Jenkinsfile:314
  #     - echo "Build Number: ${BUILD_NUMBER}" >> container-health-report.txt@Jenkinsfile:315
  #     - echo "Timestamp: $(date)" >> container-health-report.txt@Jenkinsfile:316
  #     - echo "" >> container-health-report.txt@Jenkinsfile:317
  #     - echo "Container Status:" >> container-health-report.txt@Jenkinsfile:319
  #     - docker ps -a --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.State}}" >> container-health-report.txt@Jenkinsfile:320
  #     - echo "" >> container-health-report.txt@Jenkinsfile:321
  #     - CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "unknown")@Jenkinsfile:323
  #     - echo "Container State: $CONTAINER_STATUS" >> container-health-report.txt@Jenkinsfile:324
  #     - if [ "$CONTAINER_STATUS" != "running" ]; then@Jenkinsfile:326
  #     - echo "WARNING: Container is not running!" >> container-health-report.txt@Jenkinsfile:327
  #     - fi@Jenkinsfile:328
  #     - HEALTH_STATUS=$(docker inspect -f '{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "No health check defined")@Jenkinsfile:330
  #     - echo "Health Status: $HEALTH_STATUS" >> container-health-report.txt@Jenkinsfile:331
  #     - echo "" >> container-health-report.txt@Jenkinsfile:332
  #     - echo "Container Logs (last 50 lines):" >> container-health-report.txt@Jenkinsfile:334
  #     - docker logs --tail 50 ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true@Jenkinsfile:335
  #     - echo "" >> container-health-report.txt@Jenkinsfile:336
  #     - echo "Resource Usage:" >> container-health-report.txt@Jenkinsfile:338
  #     - docker stats --no-stream ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true@Jenkinsfile:339
  #     - echo "" >> container-health-report.txt@Jenkinsfile:340
  #     - echo "Network Information:" >> container-health-report.txt@Jenkinsfile:342
  #     - docker inspect -f '{{range .NetworkSettings.Networks}}IP: {{.IPAddress}}{{end}}' ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true@Jenkinsfile:343
  #     - echo "" >> container-health-report.txt@Jenkinsfile:345
  #     - echo "=== Health Check Completed ===" >> container-health-report.txt@Jenkinsfile:346
  #   REQUIRED-READ-VARS:
  #     - BUILD_NUMBER (from env)
  #     - CONTAINER_NAME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  container-health-check:
    runs-on: ubuntu-latest
    needs: deploy-docker-container
    env:
      BUILD_NUMBER: ${{ github.run_number }}
    steps:
      - name: Container Health Check
        run: |
          # set -euo pipefail
          # echo "=== Container Health Check Report ===" > container-health-report.txt
          # echo "Build Number: ${BUILD_NUMBER}" >> container-health-report.txt
          # echo "Timestamp: $(date)" >> container-health-report.txt
          # echo "" >> container-health-report.txt
          # 
          # echo "Container Status:" >> container-health-report.txt
          # docker ps -a --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.State}}" >> container-health-report.txt
          # echo "" >> container-health-report.txt
          # 
          # CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "unknown")
          # echo "Container State: $CONTAINER_STATUS" >> container-health-report.txt
          # 
          # if [ "$CONTAINER_STATUS" != "running" ]; then
          #     echo "WARNING: Container is not running!" >> container-health-report.txt
          # fi
          # 
          # HEALTH_STATUS=$(docker inspect -f '{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "No health check defined")
          # echo "Health Status: $HEALTH_STATUS" >> container-health-report.txt
          # echo "" >> container-health-report.txt
          # 
          # echo "Container Logs (last 50 lines):" >> container-health-report.txt
          # docker logs --tail 50 ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true
          # echo "" >> container-health-report.txt
          # 
          # echo "Resource Usage:" >> container-health-report.txt
          # docker stats --no-stream ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true
          # echo "" >> container-health-report.txt
          # 
          # echo "Network Information:" >> container-health-report.txt
          # docker inspect -f '{{range .NetworkSettings.Networks}}IP: {{.IPAddress}}{{end}}' ${CONTAINER_NAME} >> container-health-report.txt 2>&1 || true
          # 
          # echo "" >> container-health-report.txt
          # echo "=== Health Check Completed ===" >> container-health-report.txt
      - name: Upload Container Health Report
        uses: actions/upload-artifact@v4
        with:
          name: container-health-report
          path: container-health-report.txt

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Deliver" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile→stages→Deliver
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Deliver"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Deliver" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:352 stage('Deliver')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - tar -czf casino_game.tar.gz build/casino_game@Jenkinsfile:354
  #     - docker save ${DOCKER_IMAGE}:${DOCKER_TAG} -o ${DOCKER_IMAGE}-${DOCKER_TAG}.tar@Jenkinsfile:355
  #     - gzip ${DOCKER_IMAGE}-${DOCKER_TAG}.tar@Jenkinsfile:356
  #     - cat > delivery-summary.txt << EOF@Jenkinsfile:358
  #   REQUIRED-READ-VARS:
  #     - BUILD_NUMBER (from env)
  #     - DOCKER_IMAGE (from env)
  #     - DOCKER_TAG (from env)
  #     - CONTAINER_NAME (from env)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  deliver:
    runs-on: ubuntu-latest
    needs: 
      - build
      - static-analysis-cppcheck
      - static-analysis-clang-tidy
      - static-analysis-flawfinder
      - static-analysis-cpplint
      - memory-leak-detection
      - duplicate-code-detection
      - documentation-generation
      - complexity-analysis
      - dependency-analysis
      - build-metrics
      - test
      - code-coverage
      - build-docker-image
      - docker-vulnerability-scan-trivy
      - docker-vulnerability-scan-grype
      - deploy-docker-container
      - container-health-check
    env:
      BUILD_NUMBER: ${{ github.run_number }}
      DOCKER_TAG: ${{ github.run_number }}
    steps:
      - uses: actions/checkout@v4
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Rebuild Docker Image for Export
        run: |
          # set -euo pipefail
          # docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
      - name: Create Delivery Package
        run: |
          # set -euo pipefail
          # tar -czf casino_game.tar.gz artifacts/build-artifacts/casino_game
          # docker save ${DOCKER_IMAGE}:${DOCKER_TAG} -o ${DOCKER_IMAGE}-${DOCKER_TAG}.tar
          # gzip ${DOCKER_IMAGE}-${DOCKER_TAG}.tar
          # 
          # cat > delivery-summary.txt << EOF
          # === Delivery Summary Report ===
          # Build Number: ${BUILD_NUMBER}
          # Build Date: $(date)
          # Docker Image: ${DOCKER_IMAGE}:${DOCKER_TAG}
          # Container Name: ${CONTAINER_NAME}
          # 
          # Artifacts:
          # - casino_game.tar.gz (Binary)
          # - ${DOCKER_IMAGE}-${DOCKER_TAG}.tar.gz (Docker Image)
          # 
          # Security Scan Results:
          # - Trivy Report: trivy-report.txt
          # - Grype Report: grype-report.txt
          # 
          # Code Quality Reports:
          # - Cppcheck: cppcheck-report.txt
          # - Clang-Tidy: clang-tidy-report.txt
          # - Flawfinder: flawfinder-report.txt
          # - CPPLint: cpplint-report.txt
          # - Coverage: coverage-report.txt
          # 
          # Additional Analysis:
          # - Memory Leaks: valgrind-report.txt
          # - Duplicate Code: cpd-report.txt
          # - Documentation: docs/html/index.html
          # - Complexity: lizard-report.txt
          # - Dependencies: dependency-report.txt
          # - Build Metrics: build-metrics.txt
          # 
          # Container Status: Running
          # Health Check: container-health-report.txt
          # 
          # === Delivery Completed ===
          # EOF
      - name: Upload Final Delivery Package
        uses: actions/upload-artifact@v4
        with:
          name: delivery-package
          path: |
            casino_game.tar.gz
            *-*.tar.gz
            delivery-summary.txt

---
