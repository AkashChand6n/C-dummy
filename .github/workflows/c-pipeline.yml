# Locked-Jobs: [build, test, deliver]
# Coverage: kept=3 / required=3 / extraneous=0
# Job-Name-Check: EXACT
# Reachability: Jenkinsfile → Build/Test/Deliver stages (linear sequence)
# Orphans: none
# Note: Skeleton iteration — all job `run` scripts are deferred to Post-Edit prompts.

name: Casino Game CI/CD Pipeline

on:
  push:  
  workflow_dispatch:

jobs:
  #
  # TODO[regen-job]: Synthesize job for source stage/job "Build" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile:stage('Build')
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Build"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Build" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:4 stage('Build')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - rm -rf build@Jenkinsfile:6
  #     - cmake -B build -S .@Jenkinsfile:7
  #     - cmake --build build@Jenkinsfile:8
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  build:
    runs-on: eks-edopsclt-custom-runner
    steps:
      - uses: actions/checkout@v4
      - name: Install CMake
        run: |
           set -euo pipefail
           sudo apt-get update && sudo apt-get install -y build-essential cmake
      - name: Clean build directory
        run: |
           set -euo pipefail
           rm -rf build	  
      - name: Configure CMake
        run: |
           set -euo pipefail
           cmake -B build -S .
      - name: Build project
        run: |
           set -euo pipefail
           cmake --build build
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-executables
          path: build/

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Test" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile:stage('Test')
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Test"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Test" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:12 stage('Test')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands only)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - ./build/casino_game@Jenkinsfile:14
  #     - ./build/test_game@Jenkinsfile:15
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  test:
    runs-on: eks-edopsclt-custom-runner
    needs: build
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-executables
          path: build/
      - name: Set executable permissions
        run: |
           set -euo pipefail
           chmod +x build/casino_game build/test_game
      - name: Run casino game
        run: |
           set -euo pipefail
           echo "$RANDOM" | ./build/casino_game
      - name: Run tests
        run: |
           set -euo pipefail
           ./build/test_game

  #
  # TODO[regen-job]: Synthesize job for source stage/job "Deliver" (skeleton iteration).
  # Variant: none
  # Reachability: Jenkinsfile:stage('Deliver')
  # Why skeleton: step scripts are deferred to post-edit for safety and precision.
  # --- COPY BELOW ---
  # TASK: Regenerate a single GitHub Actions job for source stage/job "Deliver"
  # GOAL: Produce a real `steps:` list with populated `run:` blocks, strictly from the commands in the reachable window (no placeholders).
  # CONSTRAINTS:
  #   - Use only commands, flags, and Action `with` parameters visible in the "Deliver" window (including those reached via shared-library or action calls).
  #   - Resolve shared-lib functions/actions reachable from this window into concrete shell commands; do not summarize or paraphrase them.
  #   - Do not invent variables; use the exact names found in the source.
  #   - Keep the command and step order faithful to the source's execution flow.
  #   - Preserve the original YAML indentation and key order outside of the edited job's `steps:` block.
  #   - Do not drop or reorder any other jobs or top-level keys in the workflow file.
  # IMPLEMENTATION:
  #   - Language: Bash for `run` blocks. Each `run` block must begin with:
  #       run: |
  #         set -euo pipefail
  #         ...
  #   - Read ONLY the variables listed in REQUIRED-READ-VARS (as environment variables, e.g., `${ env.VAR_NAME }`).
  #   - Write ONLY the variables listed in REQUIRED-WRITE-VARS to the GitHub Actions output file (e.g., `echo "VAR_NAME=value" >> $GITHUB_OUTPUT`).
  # CONTEXT:
  #   artifact_type: jenkinsfile
  #   requirements_document: (same as current run)
  #   full_ctx_json: (same as current run)
  #   source_artifact_files: Jenkinsfile
  # OUTPUT: Return the FULL updated workflow YAML, preserving every byte outside the edited scope.
  #   - Modify ONLY the targeted job's `steps:` block; keep all other jobs, top-level keys, `needs`, and `if` conditions unchanged.
  #   - Do NOT wrap the output in Markdown code fences.
  # --- COPY ABOVE ---
  #
  #
  # LOGIC-LEDGER:
  #   ENTRYPOINTS:
  #     - Jenkinsfile:19 stage('Deliver')
  #   CALL-GRAPH (ordered):
  #     - (none - direct shell commands and archiveArtifacts)
  #   CONCRETE-COMMANDS (ordered, as-seen):
  #     - tar -czf casino_game.tar.gz build/casino_game@Jenkinsfile:21
  #     - archiveArtifacts artifacts: 'casino_game.tar.gz', fingerprint: true@Jenkinsfile:22
  #   REQUIRED-READ-VARS:
  #     - (none)
  #   REQUIRED-WRITE-VARS:
  #     - (none)
  #   UNRESOLVED (must be empty for post-edit to proceed safely):
  #     - (none)
  #
  deliver:
    runs-on: eks-edopsclt-custom-runner
    needs: test
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-executables
          path: build/
      - name: Package casino game
        run: |
           set -euo pipefail
           tar -czf casino_game.tar.gz build/casino_game
      - name: Upload final artifact
        uses: actions/upload-artifact@v4
        with:
          name: casino-game-release
          path: casino_game.tar.gz
